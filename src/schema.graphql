# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account implements BaseAccount {
  account_number: Int!
  address: String!
  coins: [Coin!]!
  public_key: PublicKeyUnion
  sequence: Int!
}

type AggregateExchangeRatePrevote {
  hash: String!
  submit_block: Int!
  voter: String!
}

type AggregateExchangeRateVote {
  exchange_rate_tuples: [Coin!]!
  voter: String!
}

scalar Anything

type ApplicationVersion {
  build_deps: [String!]!
  build_tags: String!
  client_name: String!
  commit: String!
  go: String!
  name: String!
  server_name: String!
  version: String!
}

type Auth {
  accountInfo(address: String!): Account!
}

type AuthorizationGrant {
  authorization: AuthorizationUnion!
  expiration: String!
}

union AuthorizationUnion = GenericAuthorization | SendAuthorization

type Bank {
  balance(address: String!, height: Float): [Coin!]!
}

interface BaseAccount {
  account_number: Int!
  address: String!
  coins: [Coin!]!
  public_key: PublicKeyUnion
  sequence: Int!
}

type Block {
  data: BlockData!
  evidence: Evidence!
  header: Header!
  last_commit: LastCommit!
}

type BlockData {
  txs: [String!]
}

type BlockId {
  hash: String!
  parts: Parts!
}

type BlockInfo {
  block: Block!
  block_id: BlockId!
}

type CodeInfo {
  code_creator: String!
  code_hash: String!
}

type Coin {
  amount: String!
  denom: Denom!
}

input CoinInput {
  amount: String!
  denom: Denom!
}

type CommissionRates {
  max_change_rate: String!
  max_rate: String!
  rate: String!
}

type CommunityPoolSpendContent implements ProposalContent {
  amount: [Coin!]!
  description: String!
  recipient: String!
  title: String!
}

type ContractInfo {
  address: String!
  admin: String
  code_id: Int!
  init_msg: JSON!
  migratable: Boolean
  owner: String!
}

type DelegateValidator {
  address: String!
  proposer_priority: String!
  pub_key: String!
  voting_power: String!
}

type Delegation {
  balance: Coin!
  delegator_address: String!
  shares: String!
  validator_address: String!
}

enum Denom {
  uaud
  ucad
  uchf
  ucny
  udkk
  ueur
  ugbp
  uhkd
  uinr
  ujpy
  ukrw
  uluna
  umnt
  unok
  unused
  usdr
  usek
  usgd
  uthb
  uusd
}

type DepositParams {
  max_deposit_period: Int!
  min_deposit: [Coin!]!
}

type Distribution {
  communityPool: [Coin!]!
  parameters: DistributionParams!
  rewards(delegator: String!): Rewards!
  validatorRewards(validator: String!): ValidatorRewards!
  withdrawAddress(delegator: String!): String!
}

type DistributionParams {
  base_proposer_reward: String
  bonus_proposer_reward: String
  community_tax: String
  withdraw_addr_enabled: Boolean
}

type Evidence {
  evidence: String
}

type ExchangeRatePrevote {
  denom: Denom
  hash: String
  submit_block: Int
  voter: String
}

type ExchangeRateVote {
  denom: Denom
  exchange_rate: String!
  voter: String
}

type GenericAuthorization {
  grant_msg_type: String!
}

type Gov {
  depositParameters: DepositParams!
  deposits(proposalId: Int!): [MsgDeposit!]!
  parameters: GovParams!
  proposal(proposalId: Int!): Proposal!
  proposals: [Proposal!]!
  proposer(proposalId: Int!): String!
  tally(proposalId: Int!): Tally!
  tallyParameters: TallyParams!
  votes(proposalId: Int!): [MsgVote!]!
  votingParameters: VotingParams!
}

type GovParams {
  deposit_params: DepositParams
  tally_params: TallyParams
  voting_params: VotingParams
}

type Header {
  app_hash: String!
  chain_id: String!
  consensus_hash: String!
  data_hash: String!
  evidence_hash: String!
  height: String!
  last_block_id: BlockId!
  last_commit_hash: String!
  last_results_hash: String!
  next_validators_hash: String!
  proposer_address: String!
  time: String!
  validators_hash: String!
  version: Version!
}

type IOData {
  address: String!
  coins: [Coin!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type LastCommit {
  block_id: BlockId!
  height: String!
  round: String!
  signatures: [Signature!]!
}

type Market {
  parameters: MarketParams!
  swapRate(askDenom: Denom!, height: Float, offerCoin: CoinInput!): Coin!
  terraPoolDelta: String!
}

type MarketParams {
  base_pool: String
  min_stability_spread: String
  pool_recovery_period: Int
}

type Mint {
  annualProvisions: String!
  inflation: String!
  parameters: MintingParams!
}

type MintingParams {
  blocks_per_year: Int
  goal_bonded: String
  inflation_max: String
  inflation_min: String
  inflation_rate_change: String
  mint_denom: Denom
}

type MsgDeposit {
  amount: [Coin!]!
  depositor: String!
  proposal_id: Int!
}

type MsgVote {
  option: VoteOption!
  proposal_id: Int!
  voter: String!
}

type Msgauth {
  grants(grantee: String!, granter: String!, msgType: String): [AuthorizationGrant!]!
}

type MultisigPublicKey {
  pubkeys: [PublicKey!]!
  threshold: String!
  type: String!
}

type NodeInfo {
  application_version: ApplicationVersion!
  channels: String!
  id: ID!
  listen_addr: String!
  moniker: String!
  network: String!
  other: OtherInfo!
  protocol_version: ProtocolVersion!
  version: String!
}

type Oracle {
  activeDenoms: [Denom!]!
  aggregatePrevote(validator: String!): AggregateExchangeRatePrevote!
  aggregateVote(validator: String!): AggregateExchangeRateVote!
  exchangeRate(denom: String!, height: Float): Coin
  exchangeRates(height: Float): [Coin!]!
  feederAddress(validator: String!): String!
  misses(validator: String!): Int!
  parameters: OracleParams!
  prevotes(denom: String, validator: String): [ExchangeRatePrevote!]!
  votes(denom: String, validator: String): [ExchangeRateVote!]!
}

type OracleParams {
  min_valid_per_window: String
  reward_band: String
  reward_distribution_window: Int
  slash_fraction: String
  slash_window: Int
  vote_period: Int
  vote_threshold: String
  whitelist: [OracleWhitelist!]
}

type OracleWhitelist {
  name: String!
  tobin_tax: String!
}

type OtherInfo {
  rpc_address: String!
  tx_index: String!
}

type ParameterChangeContent implements ProposalContent {
  changes: ParameterChangesUnion
  description: String!
  title: String!
}

union ParameterChangesUnion = DistributionParams | GovParams | MarketParams | MintingParams | OracleParams | SlashingParams | StakingParams | TreasuryParams | WasmParams

type Parts {
  hash: String!
  total: String!
}

type PolicyConstraints {
  cap: Coin!
  change_max: String!
  rate_max: String!
  rate_min: String!
}

type Proposal {
  content: ProposalContentUnion!
  deposit_end_time: String!
  final_tally_result: Tally!
  id: ID!
  proposal_status: ProposalStatus!
  submit_time: String!
  total_deposit: [Coin!]!
  voting_end_time: String!
  voting_start_time: String!
}

interface ProposalContent {
  description: String!
  title: String!
}

union ProposalContentUnion = CommunityPoolSpendContent | ParameterChangeContent | RewardWeightUpdateContent | TaxRateUpdateContent | TextContent

enum ProposalStatus {
  DepositPeriod
  Failed
  Passed
  Rejected
  VotingPeriod
}

type ProtoAuthInfo {
  fee: ProtoFee!
  signer_infos: [ProtoSignerInfos!]!
}

type ProtoCoin {
  amount: String!
  denom: String!
}

type ProtoFee {
  amount: [ProtoCoin!]!
  gas_limit: String!
  granter: String!
  payer: String!
}

type ProtoSignerInfos {
  mode_info: Anything!
  public_key: Anything!
  sequence: String!
}

type ProtoTx {
  auth_info: ProtoAuthInfo!
  body: ProtoTxBody!
  signatures: [String!]!
}

type ProtoTxBody {
  memo: String!
  messages: [Anything!]!
  timeout_height: Float!
}

type ProtocolVersion {
  app: String!
  block: String!
  p2p: String!
}

type PublicKey {
  type: String!
  value: String!
}

union PublicKeyUnion = MultisigPublicKey | PublicKey

type Query {
  auth: Auth!
  bank: Bank!
  distribution: Distribution!
  gov: Gov!
  market: Market!
  mint: Mint!
  msgauth: Msgauth!
  oracle: Oracle!
  ping: String!
  slashing: Slashing!
  staking: Staking!
  supply: Supply!
  tendermint: Tendermint!
  treasury: Treasury!
  tx: Tx!
  utils: Utils!
  wasm: Wasm!
}

type Redelegation {
  delegator_address: String!
  entries: [RedelegationEntry!]!
  validator_dst_address: String!
  validator_src_address: String!
}

type RedelegationEntry {
  balance: String!
  completion_time: String!
  creation_height: Int!
  initial_balance: String!
  shares_dst: String!
}

type RewardItem {
  reward: [Coin!]!
  validator_address: String!
}

type RewardWeightUpdateContent implements ProposalContent {
  description: String!
  reward_weight: String!
  title: String!
}

type Rewards {
  rewards: [RewardItem!]!
  total: [Coin!]!
}

type ScheduleEntry {
  end_time: String!
  ratio: String!
  start_time: String!
}

type SendAuthorization {
  spend_limit: [Coin!]!
}

type Signature {
  block_id_flag: Int!
  signature: String!
  timestamp: String!
  validator_address: String!
}

type SigningInfo {
  address: String!
  index_offset: Int!
  jailed_until: String!
  missed_blocks_counter: Int!
  start_height: Int!
  tombstoned: Boolean!
}

type Slashing {
  parameters: SlashingParams!
  signingInfos(valConsPubKey: String): [SigningInfo!]!
}

type SlashingParams {
  downtime_jail_duration: String
  max_evidence_age: Int
  min_signed_per_window: String
  signed_blocks_window: Int
  slash_fraction_double_sign: String
  slash_fraction_downtime: String
}

type Staking {
  bondedValidators(delegator: String!): [Validator!]!
  delegation(delegator: String!, validator: String!): Delegation
  delegations(delegator: String, validator: String): [Delegation!]!
  parameters: StakingParams!
  pool: StakingPool!
  redelegations(delegator: String, validatorDst: String, validatorSrc: String): [Redelegation!]!
  unbondingDelegation(delegator: String, validator: String): UnbondingDelegation
  unbondingDelegations(delegator: String, validator: String): [UnbondingDelegation!]!
  validator(validator: String!): Validator
  validators: [Validator!]!
}

type StakingParams {
  bond_denom: Denom
  historical_entries: Int
  max_entries: Int
  max_validators: Int
  unbonding_time: String
}

type StakingPool {
  bonded_tokens: Coin!
  not_bonded_tokens: Coin!
}

type StdFee {
  amount: [Coin!]!
  gas: Float!
}

type StdSignature {
  pub_key: PublicKeyUnion
  signature: String!
}

type StdTx {
  fee: StdFee!
  memo: String!
  msg: [Anything!]!
  signatures: [StdSignature!]!
}

type Supply {
  total: [Coin!]!
}

type Tally {
  abstain: Int!
  no: Int!
  no_with_veto: Int!
  yes: Int!
}

type TallyParams {
  quorum: String!
  threshold: String!
  veto: String!
}

type TaxRateUpdateContent implements ProposalContent {
  description: String!
  tax_rate: String!
  title: String!
}

type Tendermint {
  blockInfo(height: Int): BlockInfo!
  nodeInfo: NodeInfo!
  syncing: Boolean!
  validatorSet(height: Int): ValidatorSet!
}

type TextContent implements ProposalContent {
  description: String!
  title: String!
}

type Treasury {
  parameters: TreasuryParams!
  rewardWeight: String!
  seigniorageProceeds: Coin!
  taxCap(denom: Denom!): Coin!
  taxProceeds: [Coin!]!
  taxRate(height: Int): String!
}

type TreasuryParams {
  mining_increment: String
  reward_policy: PolicyConstraints
  seigniorage_burden_target: String
  tax_policy: PolicyConstraints
  window_long: Int
  window_probation: Int
  window_short: Int
}

type Tx {
  byHeight(height: Float!): [TxInfo!]!
  txInfo(txHash: String!): TxInfo!
}

type TxEventKV {
  key: String!
  value: String
}

type TxEventLog {
  attributes: [TxEventKV!]!
  type: String!
}

type TxInfo {
  code: Int
  codespace: String
  gas_used: Int!
  gas_wanted: Int!
  height: Int!
  logs: [TxLog!]
  raw_log: String
  timestamp: String!
  tx: ProtoTx!
  txhash: String!
}

type TxLog {
  events: [TxEventLog!]!
  log: String
  msg_index: Int
}

type UnbondingDelegation {
  delegator_address: String!
  entries: [UnbondingDelegationEntry!]!
  validator_address: String!
}

type UnbondingDelegationEntry {
  balance: String!
  completion_time: String!
  creation_height: Int!
  initial_balance: String!
}

type Utils {
  calculateTax(coin: CoinInput!): Coin!
  validatorsWithVotingPower: [ValidatorVotingPower!]!
}

type Validator {
  commission: ValidatorCommission!
  consensus_pubkey: String!
  delegator_shares: String!
  description: ValidatorDescription!
  jailed: Boolean!
  min_self_delegation: String!
  operator_address: String!
  status: Int!
  tokens: String!
  unbonding_height: Int!
  unbonding_time: String!
}

type ValidatorCommission {
  commission_rates: CommissionRates!
  update_time: String!
}

type ValidatorDescription {
  details: String!
  identity: String!
  moniker: String!
  security_contact: String!
  website: String!
}

type ValidatorRewards {
  self_bond_rewards: [Coin!]!
  val_commission: [Coin!]!
}

type ValidatorSet {
  block_height: String!
  validators: [DelegateValidator!]!
}

type ValidatorVotingPower {
  proposer_priority: Int!
  validator: Validator!
  voting_power: Int!
}

type Version {
  app: String!
  block: String!
}

type VestingSchedule {
  denom: String!
  schedules: [ScheduleEntry!]!
}

enum VoteOption {
  Abstain
  Empty
  No
  NoWithVeto
  Yes
}

type VotingParams {
  voting_period: Int!
}

type Wasm {
  codeInfo(codeID: Int!): CodeInfo!
  contractInfo(contractAddress: String!): ContractInfo!
  contractQuery(contractAddress: String!, height: Float, query: JSON!): Anything!
  parameters: WasmParams!
}

type WasmParams {
  max_contract_gas: Int
  max_contract_msg_size: Int
  max_contract_size: Int
}
